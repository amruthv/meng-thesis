%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Introduction} \label{intro}
Robotic systems are becoming increasingly commercial (e.g. the Roomba, self driving cars) yet the field of robotics is far from having completely autonomous robots. There is still room for improvement in such a way as to handle tasks and operate with assistance. A robotic system excels when using the aforementioned systems is easier than having a human perform the task or even monitor the robot's performance.

Having a robot identify a series of actions to perform to accomplish a goal is a challenging task. The robot requires a good encoding of the world (representing the constraints of the world), its own dynamics, as well as a method for translating any decisions the robot decides to make into physical actions that it can impart into the world. Other difficulty can lay in the actual search problem of identifying the symbolic sequence of actions to take that would result in the desired outcome. This can be further complicated with uncertainty in the world as well as error in actual execution of any actions changing the expected resulting states.

\section{Planners} \label{intro:planners}
The component of a robot responsible for determining the actions to take is its planner. These invisible systems are used to make sense of the task to be performed. Planners use two types of planning: task and motion planning. 

A task planning problem is often fomulated using the language PDDL \todo{cite PDDL} formulated as a triple ($A, s_0, g$). A specifies all actions that can be taken along with their corresponding preconditions and postconditions. The task planning problem looks for a series of actions that can take the initial state $s_0$ to a final state $s_{n}$ that contains all of the propositions in $g$. 

A motion planning problem is a continuous problem specified by the configuration space $C$, a start configuration $s$ and a goal configuration $g$ for $s,g \in C$. The planning problem is successful if there exists a path from $s$ to $g$ that is not in violation with any of the obstacles in the space in which the robot operates. \todo{What is the exact name for this} 

Planners use these two types of planning to discover a complete plan. Some planners integrate discrete task planning with continuous motion planning. Many of these techniques use motion planners to verify plans found by task planners. Other techniques more closely intertwine the two planning strategies such each planning component can influence the other. 

\section{A Need for Collision Tolerant Motion Planning} \label{intro:collisiontolerant}
Many recent planning methods rely on being able to identify avenues of making motion planning problems feasible. A method of doing this is to find a path $p:s \rightarrow g$ that tolerates collisions. Evaluating collisions along $p$ determines a path that would be collision-free if these collisions were resolved (e.g. moved to a different location in the world). Thus, non-traditional motion planning that can find paths that tolerate collisions is highly valuable. 

Two such planners that require a method of identifying failure reasons are Srivastava's planning with an interface layer and Kaelbling and Lozano-P\'{e}rez's pre-image hierarchical planner \todo{cite Srivastava} \todo{cite pre-image}. Srivastava's planner first finds a task plan for the given planning problem using symbolic references. The interface layer then searches through all assignments of the symbolic references and collision-free motion plans that satisfy the chosen assignments. If no such complete instantiation of poses exists that has a error-free motion plan, the original task plan cannot be resolved into a motion plan. 

However, such a motion planner could introduce overall performance penalties if it was overly-aggressive in tolerating collisions with obstacles. Since the task planner uses the collisions provided to inform its further decisions if the motion planner needlessly introduces new collisions, these new collisions would have to be removed leading to performance losses in solving those sub-planning problems. The planner must be careful in paths that it finds.

\section{Research Problem Statement} \label{intro:statement}
The particular problem we will be addressing in the paper is the Minimum Constraint Removal (MCR) problem as formulated by Kris Hauser \cite{hauser:mcr}
\newline

\noindent
{\bf{Discrete-MCR Problem:}}\\
Input: Graph $G = (V,E)$, Cover Function $C[v]$, $s,g \in V$  \\
Output: $S^{*}_g$
\newline

The MCR problem statement assumes that a graph $G$ of configurations $q \in V$ already exists with predefined edges $e \in E$ between them. The cover $C[q]$ of a configuration $q$ is the subset of of obstacles \{1,2,3,...,m\} with which the robot collides with if placed at the configuration $q$. Let $S_q$ be the cover (possibly optimal) of the path from $s \rightarrow q$. $S^{*}$ is the answer the the MCR problem, that is the minimum number of obstacles that can be in collision with the robot while following some path p[t], t:[0,1], from a start configuration $s$ to a goal configuration $g$. Thus $S^{*} = S^{*}_g$. $S^{*}$ is defined as the minimum constraint removal and is the cover along this minimum collision path. 

The difficulty of this problem falls into the class of NP-hard problems (the proof can be seen in Hauser's paper). Since computing the precise answer is impractical, we instead must look for an algorithm that runs quickly in practice for most situations and finds a good (not perfect) answer in practice.

In the rest of this paper we will focus on a number of algorithms that can be used to find paths that support constraint violations. Note that these algorithms will not always find the $MCR$ solution. Each of these algorithms will offer different tradeoffs in running time and quality of paths as measured by collisions.

Because solving the MCR problem is impractical, we will look for an algorithm that performs well in scenarios that are most common, worlds that have feasible paths (e.g. that are largely collision free). That is, it should not introduce collisions when it does not need to. It must be able to support collisions in the less frequent world where a collision free path does not exist, but be selective to approximate the real MCR.
