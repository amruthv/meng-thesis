%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Introduction} \label{intro}
Robotic systems are becoming increasingly commercial (e.g. the Roomba, self driving cars) yet the field of robotics is far from having completely autonomous robots. There is still room for improvement in such a way as to handle tasks and operate with assistance. A robotic system is only useful when using the aforementioned systems are easier to use than having a human had do the task or even be tightly coupled with the robot's performance.

Having a robot identify a series of actions to perform to accomplish a goal is a challenging task. The robot requires a good encoding of the world (representing the constraints of the world), its own dynamics, as well as a method for translating any decisions the robot decides to make into physical actions that it can impart into the world. Other difficulty can lay in the actual search problem of identifying the symbolic sequence of actions to take that would result in the desired outcome. This can be further complicated with uncertainty in the world as well as error in actual execution of any actions changing the expected resulting states.

\section{Planners} \label{intro:planners}
The component of a robot responsible for determining the actions to take is its planner. These invisible systems are used to make sense of the task to be performed. This usually involves two components - settling on an order of tasks that need to be performed (e.g. lift block A, put down block B) that can modify the external state of the world as well the exact movements needed to carry out these tasks. The first component is handled by a task planner while the second is handled by a motion planner. 

These two types of planners work together to come up with the complete plan. Because the task planner is involved with deciding on tasks, it can be thought of as the high level planning component, while the motion planner is involved at a micro scale dealing with finding a series of movements to accomplish the task. Traditional motion planners only look for feasible paths, paths that do not have any constraint violations, or collisions, with objects in the world. That is, for motion planners to succeed, they usually require that the planning problem passed to them is already in a constrained world such that there exists some feasible path. 

\section{Shortcomings of Traditional Planners} \label{intro:shortcomings}
While traditional motion planners are adept at handling the case that they were intended for, they aren't robust to situations where no feasible path actually exists. If the task planner passes a planning problem to the motion planner with no feasible path, traditional motion planners will inevitably fail. Consequently this delegates the entire responsibility of configuring the world in a way that the motion planner can succeed to the task planner. However, these motion planners don't provide information as to why they were unable to find a path -- the task planner must then try to infer the reason for failure or randomly search actions that enable the motion planner to succeed.

Instead, in the event that there did not exist a feasible path, if the motion planner were able to return paths that made some minimal number of collisions, then the task planner could plan around the information that a path exists if these violations were moved out of the way. This inter-component communication would then lead to an overall speed up of planners and make them more robust to world settings and difficulty in planning problems.

However, such a motion planner could introduce overall performance penalties if it was overly-aggressive in tolerating collisions with obstacles. Since the task planner uses the collisions provided to inform its further decisions if the motion planner needlessly introduces new collisions, these new collisions would have to be removed leading to performance losses in solving those sub-planning problems. The planner must be careful in paths that it finds.

\section{Research Problem Statement} \label{intro:statement}
The particular problem we will be addressing in the paper is the Minimum Constraint Removal (MCR) problem as formulated by Kris Hauser \cite{hauser:mcr}
\newline

\noindent
{\bf{Discrete-MCR Problem:}}\\
Input: Graph $G = (V,E)$, Cover Function $C[v]$, $s,g \in V$  \\
Output: $S^{*}_g$
\newline

The MCR problem statement assumes that a graph $G$ of configurations $q \in V$ already exists with predefined edges $e \in E$ between them. The cover $C[q]$ of a configuration $q$ is the subset of of obstacles \{1,2,3,...,m\} with which the robot collides with if placed at the configuration $q$. Let $S_q$ be the cover (possibly optimal) of the path from $s \rightarrow q$. $S^{*}$ is the answer the the MCR problem, that is the minimum number of obstacles that can be in collision with the robot while following some path p[t], t:[0,1], from a start configuration $s$ to a goal configuration $g$. Thus $S^{*} = S^{*}_g$. $S^{*}$ is defined as the minimum constraint removal and is the cover along this minimum collision path. 

The difficulty of this problem falls into the class of NP-hard problems (the proof can be seen in Hauser's paper). Since computing the precise answer is impractical, we instead must look for an algorithm that runs quickly in practice for most situations and finds a good (not perfect) answer in practice.

In the rest of this paper we will focus on a number of algorithms that can be used to find paths that support constraint violations. Note that these algorithms will not always find the $MCR$ solution. Each of these algorithms will offer different tradeoffs in running time and quality of paths as measured by collisions.

Because solving the MCR problem is impractical, we will look for an algorithm that performs well in scenarios that are most common, worlds that have feasible paths (e.g. that are largely collision free). That is, it should not introduce collisions when it does not need to. It must be able to support collisions in the less frequent world where a collision free path does not exist, but be selective to approximate the real MCR.
